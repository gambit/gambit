#!/usr/bin/env gsi-script
;; Copyright (c) 2024 by Macon Gambill, all rights reserved.

(load "adorn/adorn")
(load "write-macros+vars.scm")

(define (main . args)
  (write-annotated-texinfo (file->char-list (car args))))

(define (file->char-list file)
  (call-with-input-file file
    (lambda (p) (read-all p read-char))))

(define (write-chars char-list) (for-each write-char char-list))

(define (whitespace-char? c) (member c '(#\space #\newline #\tab) char=?))

(define (head-match? goal actual)
  (or (null? goal)
      (and (not (null? actual))
           (char=? (car goal) (car actual))
           (head-match? (cdr goal) (cdr actual)))))

(define (looking-forward-to? goal actual)
  (and (not (null? actual))
       (or (head-match? goal actual)
           (and (whitespace-char? (car actual))
                (looking-forward-to? goal (cdr actual))))))

(define (looking-forward-to-one-of? goals actual)
  (and (not (null? goals))
       (or (looking-forward-to? (car goals) actual)
           (looking-forward-to-one-of? (cdr goals) actual))))

(define write-annotated-texinfo
  (let ((pre-lisp/rest
         (let* ((start-lisp (string->list "@lisp\n"))
                (start-length (length start-lisp)))
           (lambda (char-list)
             (let loop ((rest char-list) (pre-lisp '()))
               (cond ((null? rest) (list (reverse pre-lisp) rest))
                     ((and (head-match? start-lisp rest)
                           (or (null? pre-lisp) (char=? (car pre-lisp)
                                                        #\newline)))
                      (list (append (reverse pre-lisp) start-lisp)
                            (list-tail rest start-length)))
                     (else (loop (cdr rest) (cons (car rest) pre-lisp))))))))
        (lisp-body/rest
         (let ((end-lisp (string->list "\n@end lisp\n")))
           (lambda (char-list)
             (let loop ((rest char-list) (lisp '()))
               (if (head-match? end-lisp rest)
                   (list (reverse lisp) rest)
                   (loop (cdr rest) (cons (car rest) lisp))))))))
    (lambda (char-list)
      (unless (null? char-list)
        (let ((pl/r (pre-lisp/rest char-list)))
          (let ((pre-lisp (car pl/r)) (rest (cadr pl/r)))
            (write-chars pre-lisp)
            (unless (null? rest)
              (let ((lb/r (lisp-body/rest rest)))
                (let ((lisp-body (car lb/r)) (rest (cadr lb/r)))
                  (write-lisp lisp-body)
                  (write-annotated-texinfo rest))))))))))

(define write-lisp
  (let ((hex->char (lambda (chars)
                     (integer->char (string->number (list->string chars) 16))))
        (collect-hex (lambda (chars)
                       (let loop ((rest (list-tail chars 3)) (chars '()))
                         (let ((char (car rest)))
                           (if (char=? char #\})
                               (reverse chars)
                               (loop (cdr rest) (cons char chars))))))))
    (let ((lisp-expression/rest/class
           (let ((ok-opening (string->list "@ok{"))
                 (exception-opening (string->list "@exception{"))
                 (problem-opening (string->list "@problem{"))
                 (atchar (string->list "@atchar{}"))
                 (lbracechar (string->list "@lbracechar{}"))
                 (rbracechar (string->list "@rbracechar{}")))
             (let ((atchar-length (length atchar))
                   (bracechar-length (length lbracechar)))
               (lambda (chars)
                 (let loop ((rest chars) (expr '()))
                   (cond ((null? rest) (list (reverse expr) rest 'n/a))
                         ((looking-forward-to? ok-opening rest)
                          (list (reverse expr) rest 'ok))
                         ((looking-forward-to? exception-opening rest)
                          (list (reverse expr) rest 'exception))
                         ((looking-forward-to? problem-opening rest)
                          (list (reverse expr) rest 'problem))
                         ((head-match? '(#\@ #\U #\{) rest)
                          (let ((hex-chars (collect-hex rest)))
                            (let ((skip (+ 4 (length hex-chars)))
                                  (char (hex->char hex-chars)))
                              (loop (list-tail rest skip) (cons char expr)))))
                         ((head-match? '(#\@ #\@) rest)
                          (loop (cddr rest) (cons #\@ expr)))
                         ((head-match? '(#\@ #\{) rest)
                          (loop (cddr rest) (cons #\{ expr)))
                         ((head-match? '(#\@ #\}) rest)
                          (loop (cddr rest) (cons #\} expr)))
                         ((head-match? atchar rest)
                          (loop (list-tail rest bracechar-length) (cons #\@ expr)))
                         ((head-match? lbracechar rest)
                          (loop (list-tail rest bracechar-length) (cons #\{ expr)))
                         ((head-match? rbracechar rest)
                          (loop (list-tail rest bracechar-length) (cons #\} expr)))
                       (else (loop (cdr rest) (cons (car rest) expr)))))))))
          (pre-lisp-result/rest
           (lambda (chars)
             (let loop ((rest chars) (pre-result '()))
               (if (null? rest)
                   (list (reverse pre-result) rest)
                   (let ((nc (car rest)))
                     (if (whitespace-char? nc)
                         (loop (cdr rest) (cons nc pre-result))
                         (let ((extra (let loop ((rest rest) (extra '()))
                                        (if (null? rest)
                                            extra
                                            (let ((nc (car rest)))
                                              (if (char=? nc #\{)
                                                  (cons nc extra)
                                                  (loop (cdr rest)
                                                        (cons nc extra))))))))
                           (list (reverse (append extra pre-result))
                                 (list-tail rest (length extra))))))))))
          (lisp-result/rest
           (let ((atchar (string->list "@atchar{}"))
                 (lbracechar (string->list "@lbracechar{}"))
                 (rbracechar (string->list "@rbracechar{}")))
             (let ((atchar-length (length atchar))
                   (bracechar-length (length lbracechar)))
               (lambda (chars)
                 (let loop ((rest chars) (result '()))
                   (cond ((null? rest) (list (reverse result) rest))
                         ((head-match? '(#\@ #\U #\{) rest)
                          (let ((hex-chars (collect-hex rest)))
                            (let ((skip (+ 4 (length hex-chars)))
                                  (char (hex->char hex-chars)))
                              (loop (list-tail rest skip) (cons char result)))))
                         ((head-match? '(#\@ #\@) rest)
                          (loop (cddr rest) (cons #\@ result)))
                         ((head-match? '(#\@ #\{) rest)
                          (loop (cddr rest) (cons #\{ result)))
                         ((head-match? '(#\@ #\}) rest)
                          (loop (cddr rest) (cons #\f result)))
                         ((head-match? atchar rest)
                          (loop (list-tail rest atchar-length)
                                (cons #\@ result)))
                         ((head-match? lbracechar rest)
                          (loop (list-tail rest bracechar-length)
                                (cons #\{ result)))
                         ((head-match? rbracechar rest)
                          (loop (list-tail rest bracechar-length)
                                (cons #\} result)))
                         (else
                          (let ((nc (car rest)))
                            (if (char=? (car rest) #\})
                                (list (reverse result) rest)
                                (loop (cdr rest) (cons nc result)))))))))))
        ;; (rev-atchar-start (cdr (reverse atchar)))
        ;; (rev-lbrace-start (cdr (reverse lbracechar)))
        ;; (rev-rbrace-start (cdr (reverse rbracechar)))
        ;; (asl (- (length atchar) 1))
        ;; (xbsl (- (length lbracechar) 1)))
    ;; (lambda (chars)
    ;;   (let loop ((rest chars) (result '()))
    ;;     (cond ((null? rest) (list (reverse result) rest))
    ;;           ((head-match? '(#\@ #\U #\{) rest)
    ;;            (let ((hex-chars (collect-hex rest)))
    ;;              (let ((skip (+ 4 (length hex-chars)))
    ;;                    (char (hex->char hex-chars)))
    ;;                (loop (list-tail rest skip) (cons char result)))))
    ;;           (else
    ;;            (let ((nc (car rest)))
    ;;              (cond ((char=? nc #\@)
    ;;                     (cond ((head-match? rev-atchar-start result)
    ;;                            (loop (cdr rest)
    ;;                                  (cons nc (list-tail result asl))))
    ;;                           ((char=? (car result) #\@)
    ;;                            (loop (cdr rest)
    ;;                                  (cons nc (cdr result))))
    ;;                           (else (loop (cdr rest) (cons nc result)))))
    ;;                    ((char=? nc #\{)
    ;;                     (cond ((head-match? rev-lbrace-start result)
    ;;                            (loop (cdr rest)
    ;;                                  (cons nc (list-tail result xbsl))))
    ;;                           ((char=? (car result) #\@)
    ;;                            (loop (cdr rest)
    ;;                                  (cons nc (cdr result))))
    ;;                           (else (loop (cdr rest) (cons nc result)))))
    ;;                    ((char=? nc #\})
    ;;                     (cond ((head-match? rev-rbrace-start result)
    ;;                            (loop (cdr rest)
    ;;                                  (cons nc (list-tail result xbsl))))
    ;;                           ((char=? (car result) #\@)
    ;;                            (loop (cdr rest)
    ;;                                  (cons nc (cdr result))))
    ;;                           (else (list (reverse result) rest))))
    ;;                    (else (loop (cdr rest) (cons nc result))))))))))))
          (post-lisp-result/rest
           (lambda (chars)
             (let loop ((rest (cdr chars)) (post-result '(#\})))
               (if (null? rest)
                   (list (reverse post-result) rest)
                   (let ((nc (car rest)))
                     (if (whitespace-char? nc)
                         (loop (cdr rest) (cons nc post-result))
                         (list (reverse post-result) rest)))))))
          (adorn+simplify
           (lambda (chars)
             (adorn#reverse+simplify-kinds! (adorn#adorn! chars)))))
      (lambda (chars)
        (unless (null? chars)
          (let ((expr/rest/class (lisp-expression/rest/class chars)))
            (let ((expression (car expr/rest/class))
                  (rest (cadr expr/rest/class))
                  (class (caddr expr/rest/class)))
              (write-ac-list (adorn+simplify expression))
              (unless (null? rest)
                (let ((pre-result/rest (pre-lisp-result/rest rest)))
                  (let ((pre-result (car pre-result/rest))
                        (rest (cadr pre-result/rest)))
                    (write-chars pre-result)
                    (let ((result/rest (lisp-result/rest rest)))
                      (let ((result (car result/rest))
                            (rest (cadr result/rest)))
                        (if (eq? class 'ok)
                            (write-ac-list (adorn+simplify result))
                            (write-chars result))
                        (let ((post-result/rest (post-lisp-result/rest rest)))
                          (let ((post-result (car post-result/rest))
                                (rest (cadr post-result/rest)))
                            (write-chars post-result)
                            (write-lisp rest)))))))))))))))

(define write-ac-list
  (let ((char->texi-char
         (let ((texinfo-safe (append '(#\space #\newline)
                                     (char-set->list
                                      (char-set-intersection
                                       char-set:letter+digit
                                       char-set:ascii)))))
           (letrec ((zero-pad (lambda (char-list)
                                (if (> 4 (length char-list))
                                    (zero-pad (cons #\0 char-list))
                                    char-list))))
             (let ((char->texinfo-maybe-U
                    (lambda (char)
                      (if (member char texinfo-safe char=?)
                          (list char)
                          (append '(#\@ #\U #\{)
                                  (zero-pad
                                   (map char-upcase
                                        (string->list
                                         (number->string (char->integer char)
                                                         16))))
                                  '(#\}))))))
               (lambda (char)
                 (cond ((char=? char #\&) (string->list "@ampchar{}"))
                       ((char=? char #\@) (string->list "@atchar{}"))
                       ((char=? char #\\) (string->list "@backslashchar{}"))
                       ((char=? char #\,) (string->list "@comma{}"))
                       ((char=? char #\#) (string->list "@hashchar{}"))
                       ((char=? char #\{) (string->list "@lbracechar{}"))
                       ((char=? char #\}) (string->list "@rbracechar{}"))
                       ((char=? char #\ ) (string->list "@ "))
                       (else (char->texinfo-maybe-U char))))))))
        (close-macro (lambda () (write-char #\})))
        (kind->macro-open
         (lambda (kind) (append '(#\@) (kind->macro-name kind) '(#\{)))))
    (let ((open-macro (lambda (kind) (write-chars (kind->macro-open kind)))))
      (lambda (ac-list)
        (let loop ((rest ac-list) (macro #f))
          (cond ((null? rest) (when macro (close-macro)))
                (else (let ((ac (car rest)))
                        (let ((nc (adorn#get-char ac)) (k (adorn#get-kind ac)))
                          (cond ((not macro)
                                 (cond ((memq k '(default whitespace))
                                        (write-chars (char->texi-char nc))
                                        (loop (cdr rest) #f))
                                       (else
                                        (open-macro k)
                                        (write-chars (char->texi-char nc))
                                        (loop (cdr rest) k))))
                                (else (cond ((memq k (list macro 'whitespace))
                                             (write-chars (char->texi-char nc))
                                             (loop (cdr rest) macro))
                                            ((eq? k 'default)
                                             (close-macro)
                                             (write-chars (char->texi-char nc))
                                             (loop (cdr rest) #f))
                                            (else (close-macro)
                                                  (open-macro k)
                                                  (write-chars
                                                   (char->texi-char nc))
                                                  (loop (cdr rest)
                                                        k))))))))))))))
