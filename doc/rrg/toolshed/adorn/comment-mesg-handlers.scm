;; Copyright (c) 2024 by Macon Gambill, all rights reserved.

(define try-linec-pm!
  (let ((linec:p/d (lambda (ac-list)
                     (let seek ((rest ac-list) (distance 1))
                       (let ((ac (car rest)))
                         (if (char=? (get-char ac) #\;)
                             (cons ac distance)
                             (seek (cdr rest) (+ distance 1))))))))
    (let ((peer/top-peer/stack/distance
           (lambda (ac-list)
             (let* ((p/d (linec:p/d ac-list))
                    (peer (car p/d))
                    (top-peer (caar (get-stack peer)))
                    (stack (get-stack peer))
                    (distance (+ (get-hop top-peer) (cdr p/d))))
               (cons peer (cons top-peer (cons stack distance)))))))
      (lambda (ac-list nc pac pm)
        (cond ((eq? pm 'linec)
               (cond ((char=? nc #\;)
                      (let ((p/tp/s/d (peer/top-peer/stack/distance ac-list)))
                        (let ((peer (car p/tp/s/d))
                              (top-peer (cadr p/tp/s/d))
                              (stack (caddr p/tp/s/d))
                              (distance (cdddr p/tp/s/d)))
                          (set-hop! top-peer distance)
                          (set-stack! peer '())
                          (adorn-char nc 'linec 'linec #f stack))))
                     ((char=? nc #\newline)
                      (let ((p/tp/s/d (peer/top-peer/stack/distance ac-list)))
                        (let ((peer (car p/tp/s/d))
                              (top-peer (cadr p/tp/s/d))
                              (stack (caddr p/tp/s/d))
                              (distance (cdddr p/tp/s/d)))
                          (set-hop! top-peer distance)
                          (set-stack! peer '())
                          (adorn-char
                           nc 'whitespace 'linec-end (- distance) stack))))
                     (else (adorn-char nc 'linec 'linec))))
              ((eq? pm 'linec-end)
               (cond ((char=? nc #\;)
                      (let* ((stack (get-stack pac)) (top-peer (caar stack)))
                        (set-hop! top-peer (+ (get-hop top-peer) 1))
                        (set-hop! pac #f)
                        (set-mesg! pac 'linec)
                        (set-stack! pac '())
                        (adorn-char nc 'linec 'linec #f stack)))
                     (else (let ((stack (get-stack pac)))
                             (if (null? stack)
                                 (try-context! ac-list nc pac)
                                 (let ((top-peer (caar stack))
                                       (context (cdar stack)))
                                   (set-hop! pac (- (get-hop top-peer)))
                                   (set-stack! pac '())
                                   (car (adorn! nc context))))))))
               (else #f))))))

(define (try-datumc-linec-pm! ac-list nc pm)
  (and (eq? pm 'datumc-linec)
       (cond ((char=? nc #\newline)
              (adorn-char nc 'datumc '~datumc))
             (else (adorn-char nc 'linec 'datumc-linec)))))

(define (handle~datumc! ac-list nc pac)
  (cond ((char=? nc #\#) (adorn-char nc 'datumc 'datumc#))
        ((char=? nc #\") (adorn-char nc 'datumc 'datumc-string-unmatched))
        ((char=? nc #\|) (adorn-char nc 'datumc 'datumc-ident-unmatched))
        ((char=? nc #\;) (adorn-char nc 'linec 'datumc-linec))
        ((memc nc compound-begin-chars) (begin-datumc-compound! ac-list nc))
        ((memc nc '(#\) #\] #\})) (datumc:end-compound! ac-list nc))
        ((or (memc nc whitespace-chars)
             (memc nc abbrev-chars)
             (and (char=? nc #\@) (memc (get-char pac) abbrev-chars)))
         (adorn-char nc 'datumc '~datumc))
        (else (adorn-char nc 'datumc 'datumc-simple-begin))))

(define (handle~datumc-compound! ac-list nc)
  (cond ((char=? nc #\#) (adorn-char nc 'datumc '~datumc-compound))
        ((char=? nc #\") (adorn-char nc 'datumc 'datumc-compound-string))
        ((char=? nc #\|) (adorn-char nc 'datumc 'datumc-compound-ident))
        ((memc nc compound-begin-chars) (begin-datumc-compound! ac-list nc))
        ((memc nc compound-end-chars) (datumc:end-compound! ac-list nc))
        (else (adorn-char nc 'datumc '~datumc-compound))))

(define (^begin-nestc! mesg)
  (lambda (ac-list nc pac)
    (set-kind! pac 'nestc)
    (set-hop! pac 0)
    (set-stack! pac (list ac-list))
    (adorn-char nc 'nestc mesg)))
(define begin-nestc! (^begin-nestc! 'nestc-begin))
(define begin-datumc-nestc! (^begin-nestc! 'datumc-nestc-begin))

(define (^handle:nestc ~mesg+ ~mesg- mesg)
  (lambda (nc)
    (cond ((char=? nc #\#) (adorn-char nc 'nestc ~mesg+))
          ((char=? nc #\|) (adorn-char nc 'nestc ~mesg-))
          (else (adorn-char nc 'nestc mesg)))))
(define handle:nestc (^handle:nestc '~nestc+ '~nestc- 'nestc))
(define handle:datumc-nestc
  (^handle:nestc '~datumc-nestc+ '~datumc-nestc- 'datumc-nestc))

(define (nestc:peer/stack/distance ac-list)
  (let seek ((rest ac-list) (distance 0))
    (let* ((peer (car rest)) (stack (get-stack peer)))
      (cond ((null? stack) (seek (cdr rest) (+ distance 1)))
            (else (cons peer (cons stack distance)))))))

(define (^increment-nestc! mesg+)
  (lambda (ac-list nc pac)
    (let ((p/s/d (nestc:peer/stack/distance ac-list)))
      (let ((peer (car p/s/d)) (stack (cadr p/s/d)) (distance (cddr p/s/d)))
        (set-stack! peer '())
        (increment-hops! stack distance)
        (set-hop! pac 0)
        (set-stack! pac (cons ac-list stack))))
    (adorn-char nc 'nestc mesg+)))
(define increment-nestc! (^increment-nestc! 'nestc+))
(define increment-datumc-nestc! (^increment-nestc! 'datumc-nestc+))

(define (^decrement-nestc! mesg-end mesg- preserve-context?)
  (lambda (ac-list nc)
    (let ((p/s/d (nestc:peer/stack/distance ac-list)))
      (let ((peer (car p/s/d)) (stack (cadr p/s/d)) (distance (cddr p/s/d)))
        (let ((adjusted-distance (+ distance 1))
              (peer-stack (get-stack peer))
              (rest (cdr stack)))
          (let ((top-peer (caar peer-stack)))
            (set-stack! peer '())
            (increment-hops! rest adjusted-distance)
            (let ((total-dist (+ (get-hop top-peer) adjusted-distance)))
              (set-hop! top-peer total-dist)
              (if (null? rest)
                  (if preserve-context?
                      (let ((context
                             (let loop ((acl (cdar peer-stack)))
                               (cond ((null? acl) '())
                                     ((memq (get-kind (car acl)) comment-kinds)
                                      (loop (cdr acl)))
                                     (else acl)))))
                        (adorn-char nc 'nestc mesg-end (- total-dist) context))
                      (adorn-char nc 'nestc mesg-end (- total-dist) rest))
                  (adorn-char nc 'nestc mesg- (- total-dist) rest)))))))))
(define decrement-nestc! (^decrement-nestc! 'nestc-end 'nestc- #t))
(define decrement-datumc-nestc!
  (^decrement-nestc! 'datumc-nestc-end 'datumc-nestc- #f))

(define (^handle~nestc+! increment-nestc! ~mesg+ mesg)
  (lambda (ac-list nc pac)
    (cond ((char=? nc #\|) (increment-nestc! ac-list nc pac))
          ((char=? nc #\#) (adorn-char nc 'nestc ~mesg+))
          (else (adorn-char nc 'nestc mesg)))))
(define handle~nestc+! (^handle~nestc+! increment-nestc! 'nestc+ 'nestc))
(define handle~datumc-nestc+!
  (^handle~nestc+! increment-datumc-nestc! 'datumc-nestc+ 'datumc-nestc))

(define (^handle~nestc-! decrement-nestc! ~mesg- mesg)
  (lambda (ac-list nc)
    (cond ((char=? nc #\#) (decrement-nestc! ac-list nc))
          ((char=? nc #\|) (adorn-char nc 'nestc ~mesg-))
          (else (adorn-char nc 'nestc mesg)))))
(define handle~nestc-! (^handle~nestc-! decrement-nestc! 'nestc- 'nestc))
(define handle~datumc-nestc-!
  (^handle~nestc-! decrement-datumc-nestc! 'datumc-nestc- 'datumc-nestc))

(define (maybe-end-datumc! ac-list nc pac pm)
  (let ((p/d (datumc:peer/distance ac-list)))
    (let ((from-peer (car p/d)) (distance (cdr p/d)))
      (let* ((nearest-peer (car from-peer))
             (peer-stack (get-stack nearest-peer))
             (top-peer (caar peer-stack))
             (total-distance (+ distance (get-hop top-peer))))
        (set-hop! top-peer total-distance)
        (let ((rest (cdr peer-stack)))
          (set-stack! nearest-peer rest)
          (set-hop! pac (- total-distance))
          (if (null? rest)
              (begin (set-mesg! pac 'datumc-end)
                     (car (adorn! nc (cdar peer-stack))))
              (cond ((char=? nc #\")
                     (adorn-char nc 'datumc 'datumc-string-unmatched))
                    ((char=? nc #\|)
                     (adorn-char nc 'datumc 'datumc-ident-unmatched))
                    ((and (eq? pm 'datumc#) (memc nc delim-chars))
                     (set-mesg! pac 'datumc-simple-end)
                     (adorn-char nc 'datumc '~datumc))
                    ((memc nc compound-begin-chars)
                     (begin-datumc-compound! ac-list nc))
                    (else (adorn-char nc 'datumc '~datumc)))))))))

(define (handle:datumc-simple! ac-list nc pac pm)
  (cond ((memc nc delim-chars) (maybe-end-datumc! ac-list nc pac pm))
        (else (adorn-char nc 'datumc 'datumc-simple))))

(define (handle:datumc~hvector! ~mesg prefix-strings)
  (let ((end-act (lambda (ac-list)
                   (set-mesg! (car ac-list) 'datumc-simple-begin))))
    (lambda (ac-list nc pac pm)
      (let ((recent-chars (append (chars-until ac-list 'datumc#) (list nc))))
        (cond ((matches-one-of? prefix-strings recent-chars)
               (begin-datumc-compound! ac-list nc))
              ((could-match-one-of? prefix-strings recent-chars)
               (adorn-char nc 'datumc ~mesg))
              (else (revise-until! ac-list 'datumc 'datumc# end-act)
                    (if (memc nc delim-chars)
                        (maybe-end-datumc! ac-list nc pac pm)
                        (adorn-char nc 'datumc 'datumc-simple))))))))

(define handle:datumc~fvector!
  (handle:datumc~hvector! '~datumc-fvector fvectors))
(define handle:datumc~svector!
  (handle:datumc~hvector! '~datumc-svector svectors))
(define handle:datumc~uvector!
  (handle:datumc~hvector! '~datumc-uvector uvectors))

(define (handle~datumc-directive! ac-list nc pac pm)
  (let ((tested (append (chars-until ac-list 'datumc#) (list nc))))
    (cond ((matches-one-of? directives tested)
           (adorn-char nc 'datumc '~datumc))
          ((could-match-one-of? directives tested)
           (adorn-char nc 'datumc '~datumc-directive))
          ((memc nc delim-chars)
           (maybe-end-datumc! ac-list nc pac pm))
          (else (adorn-char nc 'datumc 'datumc-simple)))))

(define (need-delim! ac-list nc int/mesgs)
  (cond ((memc nc delim-chars) (try-nc! ac-list nc))
        (else (revise-until! ac-list 'default int/mesgs)
              (adorn-char nc 'invalid 'invalid))))

(define (handle:datumc#! ac-list nc pac pm)
  (cond ((char=? nc #\!) (adorn-char nc 'datumc '~datumc-directive))
        ((char=? nc #\f) (adorn-char nc 'datumc '~datumc-fvector))
        ((char=? nc #\s) (adorn-char nc 'datumc '~datumc-svector))
        ((char=? nc #\u) (adorn-char nc 'datumc '~datumc-uvector))
        ((char=? nc #\\) (adorn-char nc 'datumc 'datumc-simple-begin))
        ((char=? nc #\() (begin-datumc-compound! ac-list nc))
        ((char=? nc #\|) (begin-datumc-nestc! ac-list nc pac))
        ((char=? nc #\;)
         (let ((p/d (datumc:peer/distance ac-list)))
           (let ((from-peer (car p/d)) (distance (cdr p/d)))
             (let* ((datumc-peer-stack (get-stack (car from-peer)))
                    (top-datumc-peer (caar datumc-peer-stack)))
               (increment-hops! datumc-peer-stack distance)
               (set-hop! pac 0)
               (set-stack! pac (cons ac-list datumc-peer-stack))
               (set-stack! top-datumc-peer '())))
           (adorn-char nc 'datumc '~datumc)))
        ((memc nc delim-chars) (maybe-end-datumc! ac-list nc pac pm))
        (else (adorn-char nc 'datumc 'datumc-simple))))

(define (^handle:datumc-symmetric! delim-char backslash-sym kind)
  (lambda (ac-list nc)
    (cond ((char=? nc #\\) (adorn-char nc 'datumc backslash-sym))
          ((char=? nc delim-char) (datumc:end-symmetric! ac-list nc kind))
          (else (adorn-char nc 'datumc kind)))))

(define handle:datumc-string
  (^handle:datumc-symmetric! #\" 'datumc-string-backslash 'datumc-string))

(define (handle:datumc-string-backslash ac-list nc)
  (adorn-char nc 'datumc 'datumc-string))

(define (handle:datumc-compound-string ac-list nc)
  (cond ((char=? nc #\\)
         (adorn-char nc 'datumc 'datumc-compound-string-backslash))
        ((char=? nc #\") (adorn-char nc 'datumc '~datumc-compound))
        (else (adorn-char nc 'datumc 'datumc-compound-string))))

(define (handle:datumc-compound-string-backslash ac-list nc)
  (adorn-char nc 'datumc 'datumc-compound-string))

(define handle:datumc-ident
  (^handle:datumc-symmetric! #\" 'datumc-ident-backslash 'datumc-ident))

(define (handle:datumc-ident-backslash ac-list nc)
  (adorn-char nc 'datumc 'datumc-ident))

(define (handle:datumc-compound-ident ac-list nc)
  (cond ((char=? nc #\\)
         (adorn-char nc 'datumc 'datumc-compound-ident-backslash))
        ((char=? nc #\") (adorn-char nc 'datumc '~datumc-compound))
        (else (adorn-char nc 'datumc 'datumc-compound-ident))))

(define (handle:datumc-compound-ident-backslash ac-list nc)
  (adorn-char nc 'datumc 'datumc-compound-ident))

(define (try-nestc-pm! ac-list nc pac pm)
  (cond ((memq pm '(nestc nestc-begin nestc+ nestc-)) (handle:nestc nc))
        ((eq? pm '~nestc+) (handle~nestc+! ac-list nc pac))
        ((eq? pm '~nestc-) (handle~nestc-! ac-list nc))
        (else #f)))

(define (try-datumc-pm! ac-list nc pac pm)
  (cond
   ((memq pm '( datumc-nestc datumc-nestc-begin datumc-nestc+ datumc-nestc- ))
    (handle:datumc-nestc nc))
   ((memq pm '( ~datumc datumc-simple-end datumc-compound-end datumc-string-end
                datumc-compound-string-end datumc-compound-ident-end
                datumc-ident-end datumc-nestc-end ))
    (handle~datumc! ac-list nc pac))
   ((memq pm '( ~datumc-compound datumc-compound-simple datumc-subcompound-end
                datumc-compound-unmatched datumc-subcompound-unmatched ))
    (handle~datumc-compound! ac-list nc))
   ((memq pm '( datumc-simple datumc-simple-begin))
    (handle:datumc-simple! ac-list nc pac pm))
   ((eq? pm 'datumc#)           (handle:datumc#! ac-list nc pac pm))
   ((eq? pm '~datumc-nestc+)    (handle~datumc-nestc+! ac-list nc pac))
   ((eq? pm '~datumc-nestc-)    (handle~datumc-nestc-! ac-list nc))
   ((eq? pm '~datumc-fvector)   (handle:datumc~fvector! ac-list nc pac pm))
   ((eq? pm '~datumc-svector)   (handle:datumc~svector! ac-list nc pac pm))
   ((eq? pm '~datumc-uvector)   (handle:datumc~uvector! ac-list nc pac pm))
   ((eq? pm '~datumc-directive) (handle~datumc-directive! ac-list nc pac pm))
   ((memq pm '(datumc-end nestc-end)) (let ((resumed-context (get-stack pac)))
                                        (set-stack! pac '())
                                        (car (adorn! nc resumed-context))))
   ((memq pm '(datumc-string datumc-string-unmatched))
    (handle:datumc-string ac-list nc))
   ((memq pm '(datumc-ident datumc-ident-unmatched))
    (handle:datumc-ident ac-list nc))
   ((memq pm '(datumc-compound-string datumc-compound-string))
    (handle:datumc-compound-string ac-list nc))
   ((memq pm '(datumc-compound-ident datumc-compound-ident))
    (handle:datumc-compound-ident ac-list nc))
   ((eq? pm 'datumc-string-backslash)
    (handle:datumc-string-backslash ac-list nc))
   ((eq? pm 'datumc-ident-backslash)
    (handle:datumc-ident-backslash ac-list nc))
   ((eq? pm 'datumc-compound-string-backslash)
    (handle:datumc-compound-string-backslash ac-list nc))
   ((eq? pm 'datumc-compound-ident-backslash)
    (handle:datumc-compound-ident-backslash ac-list nc))
   (else #f)))
