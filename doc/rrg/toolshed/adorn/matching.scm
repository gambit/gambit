;; Copyright (c) 2024 by Macon Gambill, all rights reserved.

(define (memc char char-list) (member char char-list char=?))
(define (memc-ci char char-list) (member char char-list char-ci=?))

(define char-complement
  (let ((remberc (lambda (char char-list)
                   (let loop ((old char-list) (new '()))
                     (cond ((null? old) new)
                           (else (let ((next (car old)))
                                   (loop (cdr old) (if (char=? char next)
                                                       new
                                                       (cons next new))))))))))
    (lambda (subset set)
      (let loop ((subset subset) (new-set set))
        (cond ((null? subset) new-set)
              (else (loop (cdr subset) (remberc (car subset) new-set))))))))

(define (char-list-backmatch goal actual)
  (let backmatch-loop ((goal (reverse goal)) (actual-rest (reverse actual)))
    (if (null? goal)
        actual
        (and (not (null? actual-rest))
             (char=? (car goal) (car actual-rest))
             (backmatch-loop (cdr goal) (cdr actual-rest))))))

(define (backmatch goal actual)
  (let ((cl-goal (if (string? goal) (string->list goal) goal))
        (cl-actual (if (string? actual) (string->list actual) actual)))
    (char-list-backmatch cl-goal cl-actual)))

(define (char-list-could-match? goal actual)
  (or (null? actual)
      (and (not (null? goal))
           (char=? (car goal) (car actual))
           (char-list-could-match? (cdr goal) (cdr actual)))))

(define (could-match? goal actual)
  (let ((cl-goal (if (string? goal) (string->list goal) goal))
        (cl-actual (if (string? actual) (string->list actual) actual)))
    (char-list-could-match? cl-goal cl-actual)))

(define (could-match-one-of? goals actual)
  (and (not (null? goals))
       (or (could-match? (car goals) actual)
           (could-match-one-of? (cdr goals) actual))))

(define (achievable-goals goals actual)
  (let loop ((old goals) (new '()))
    (if (null? old)
        new
        (let ((goal (car old)))
          (cond ((could-match? goal actual) (loop (cdr old) (cons goal new)))
                (else (loop (cdr old) new)))))))

(define (backmatch-one-of goals actual)
  (let loop ((achievable (achievable-goals goals actual)))
    (and (not (null? achievable))
         (or (backmatch (car achievable) actual) (loop (cdr achievable))))))

(define (matches? goal actual)
  (let ((cl-goal (if (string? goal) (string->list goal) goal))
        (cl-actual (if (string? actual) (string->list actual) actual)))
    (or (and (null? cl-goal) (null? cl-actual))
        (and (not (or (null? cl-goal) (null? cl-actual)))
             (char=? (car cl-goal) (car cl-actual))
             (matches? (cdr cl-goal) (cdr cl-actual))))))

(define (matches-one-of? goals actual)
  (let loop ((achievable (achievable-goals goals actual)))
    (and (not (null? achievable))
         (or (matches? (car achievable) actual) (loop (cdr achievable))))))

(define char-escape-representations
  (letrec ((zero-pad (lambda (char-list target-length)
                       (if (> target-length (length char-list))
                           (zero-pad (cons #\0 char-list) target-length)
                           char-list))))
    (lambda (char)
      (let ((int (char->integer char)))
        (let ((hex (number->string int 16)) (octal (number->string int 8)))
          (let ((hex-list (string->list hex)) (oct-list (string->list octal)))
            (let ((hex-u (zero-pad hex-list 4)) (hex-U (zero-pad hex-list 8)))
              (let ((x-chars (append '(#\\ #\x) hex-list '(#\;)))
                    (u-chars (append '(#\\ #\u) hex-u))
                    (U-chars (append '(#\\ #\U) hex-U))
                    (o-chars (append '(#\\) oct-list)))
                (let ((u-length (length u-chars))
                      (U-length (length U-chars))
                      (o-length (length o-chars)))
                  (list (list char)
                        x-chars
                        (and (= 6 u-length) u-chars)
                        (and (= 10 U-length) U-chars)
                        (and (or (= 3 o-length)
                                 (and (= 4 o-length)
                                      (memc (car oct-list)
                                            '(#\0 #\1 #\2 #\3))))
                             o-chars)))))))))))

(define (escaped-char-match goal actual)
  (let ((representations (char-escape-representations goal)))
    (let loop ((representations representations))
      (and (not (null? representations))
           (let ((representation (car representations)))
             (if (and representation
                      (let loop ((rest representation) (actuals actual))
                        (or (null? rest)
                            (and (char=? (car rest) (car actuals))
                                 (loop (cdr rest) (cdr actuals))))))
                 representation
                 (loop (cdr representations))))))))

(define (matches-escapes? goal actual)
  (or (and (null? goal) (null? actual))
      (and (not (or (null? goal) (null? actual)))
           (let* ((next (car goal))
                  (partial-match (escaped-char-match next actual)))
             (and partial-match
                  (let* ((matched-length (length partial-match))
                         (tail (list-tail actual matched-length)))
                    (matches-escapes? (cdr goal) tail)))))))

(define (case-fold-hex-escape char-list)
  (let loop ((unfolded char-list) (folded '()))
    (cond ((null? unfolded) (reverse folded))
          ((or (null? folded) (null? (cdr folded)))
           (loop (cdr unfolded) (cons (car unfolded) folded)))
          (else (loop (cdr unfolded)
                      (cons (char-foldcase (car unfolded)) folded))))))

(define (matches-one-of-escapes goals actual)
  (let ((folded (case-fold-hex-escape actual)))
    (let loop ((goals goals))
      (and (not (null? goals))
           (let ((goal (car goals)))
             (cond ((matches-escapes? goal folded) goal)
                   (else (loop (cdr goals)))))))))
