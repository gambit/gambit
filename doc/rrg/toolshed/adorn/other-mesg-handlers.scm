;; Copyright (c) 2024 by Macon Gambill, all rights reserved.

(define (^revise-if-complete kind ~mesg strings)
  (lambda (ac-list nc)
    (let* ((tested (append (chars-until ac-list 'octothorpe) (list nc)))
           (matched (backmatch-one-of strings tested)))
      (cond (matched (revise-until! ac-list kind (- (length matched) 1))
                     (adorn-char nc kind kind))
            ((could-match-one-of? strings tested)
             (adorn-char nc 'default ~mesg))
            ((memc nc delim-chars) (try-nc! ac-list nc))
            (else (adorn-char nc 'invalid 'invalid))))))

(define handle~false! (^revise-if-complete 'false '~false '("#false")))
(define handle~true! (^revise-if-complete 'true '~true '("#true")))

(define (handle~f/false/fvector! ac-list nc)
  (cond ((memc nc delim-chars) (try-nc! ac-list nc))
        ((char=? nc #\a)
         (revise-until! ac-list 'default 2)
         (handle~false! ac-list nc))
        (else (let* ((recents (chars-until ac-list 2))
                     (tested (append recents (list nc))))
                (cond ((could-match-one-of? fvectors tested)
                       (revise-until! ac-list 'default 2)
                       (handle~fvector! ac-list nc))
                      (else (adorn-char nc 'invalid 'invalid)))))))

(define (hvector-char-list->symbol cl)
  (string->symbol (list->string (append (reverse (cdr (reverse (cdr cl))))
                                        '(#\v #\e #\c #\t #\o #\r)))))

(define (^handle~hvector! ~mesg prefix-strings)
  (lambda (ac-list nc)
    (let* ((recents (chars-until ac-list 'octothorpe))
           (tested (append recents (list nc)))
           (matched (backmatch-one-of prefix-strings tested)))
      (cond (matched (let ((distance (- (length matched) 1))
                           (kind (hvector-char-list->symbol matched)))
                       (revise-until! ac-list kind distance)
                       (begin-compound! ac-list nc kind)))
            ((could-match-one-of? prefix-strings tested)
             (adorn-char nc 'default ~mesg))
            ((memc nc delim-chars) (try-nc! ac-list nc))
            (else (adorn-char nc 'invalid 'invalid))))))

(define handle~fvector! (^handle~hvector! '~fvector fvectors))
(define handle~svector! (^handle~hvector! '~svector svectors))
(define handle~uvector! (^handle~hvector! '~uvector uvectors))

(define (handle~t! ac-list nc)
  (cond ((memc nc delim-chars) (try-nc! ac-list nc))
        (else (revise-until! ac-list 'default 2)
              (handle~true! ac-list nc))))

(define (try-boolean/hvector-pm! ac-list nc pm)
  (cond ((eq? pm '~f/false/fvector) (handle~f/false/fvector! ac-list nc))
        ((eq? pm '~false)           (handle~false! ac-list nc))
        ((eq? pm '~fvector)         (handle~fvector! ac-list nc))
        ((eq? pm '~svector)         (handle~svector! ac-list nc))
        ((eq? pm '~t)               (handle~t! ac-list nc))
        ((eq? pm '~true)            (handle~true! ac-list nc))
        ((eq? pm '~uvector)         (handle~uvector! ac-list nc))
        ((memq pm '(false true))    (need-delim! ac-list nc 'octothorpe))
        (else #f)))

(define (try-box-pm! ac-list nc pm) (and (eq? pm 'box) (try-nc! ac-list nc)))

(define handle~directive!
  (^revise-if-complete 'directive '~directive directives))

(define handle~sharp!
  (^revise-if-complete 'sharp '~sharp sharp-objects))

(define (handle~directive/sharp! ac-list nc)
  (let ((tested (append (chars-until ac-list 'octothorpe) (list nc))))
    (cond ((could-match-one-of? sharp-objects tested)
           (handle~sharp! ac-list nc))
          ((could-match-one-of? directives tested)
           (handle~directive! ac-list nc))
          (else (adorn-char nc 'invalid 'invalid)))))

(define (try-directive/sharp-pm! ac-list nc pm)
  (cond ((eq? pm '~directive) (handle~directive! ac-list nc))
        ((eq? pm '~directive/sharp) (handle~directive/sharp! ac-list nc))
        ((eq? pm '~sharp) (handle~sharp! ac-list nc))
        ((memq pm '(directive sharp)) (need-delim! ac-list nc 'octothorpe))
        (else #f)))

(define (handle~hs-begin! ac-list nc)
  (cond ((char=? nc #\<)
         (revise-until! ac-list 'hs-begin 2)
         (adorn-char nc 'hs-begin '~hs-key-begin))
        ((memc nc delim-chars) (try-nc! ac-list nc))
        (else (adorn-char nc 'invalid 'invalid))))

(define (handle:hs-key ac-list nc)
  (cond ((char=? nc #\newline) (adorn-char nc 'hs-key 'hs-key-end #f ac-list))
        (else (adorn-char nc 'hs-key 'hs-key))))

(define (handle:hs-body! ac-list nc)
  (if (char=? nc #\newline)
      (let ((line/from-key (let seek ((rest ac-list) (chars '()))
                             (let* ((ac (car rest)) (char (get-char ac)))
                               (if (char=? char #\newline)
                                   (let ((stack (get-stack ac)))
                                     (set-stack! ac '())
                                     (list chars stack))
                                   (seek (cdr rest) (cons char chars)))))))
        (let ((previous-line (car line/from-key))
              (from-key (cadr line/from-key)))
          (let* ((hs-key (cdr (chars-until from-key '~hs-key-begin)))
                 (hs-key-length (length hs-key)))
            (if (or (equal? hs-key previous-line) (= hs-key-length 0))
                (begin (revise-until! ac-list 'hs-key hs-key-length)
                       (adorn-char nc 'hs-key #f))
                (adorn-char nc 'hs-body 'hs-body #f from-key)))))
      (adorn-char nc 'hs-body 'hs-body)))

(define (try-hs-pm! ac-list nc pm)
  (cond ((memq pm '(hs-body hs-key-end)) (handle:hs-body! ac-list nc))
        ((memq pm '(hs-key ~hs-key-begin)) (handle:hs-key ac-list nc))
        ((eq? pm '~hs-begin) (handle~hs-begin! ac-list nc))
        (else #f)))

(define (handle~label/ref! ac-list nc)
  (cond ((char=? nc #\=)
         (revise-until! ac-list 'datum-label 'octothorpe)
         (adorn-char nc 'datum-label #f))
        ((char=? nc #\#)
         (revise-until! ac-list 'datum-ref 'octothorpe)
         (adorn-char nc 'datum-ref #f))
        ((memc nc delim-chars)
         (revise-until! ac-list 'serial-ref 'octothorpe)
         (try-nc! ac-list nc))
        ((memc nc decimal-chars) (adorn-char nc 'default '~label/ref))
        (else (adorn-char nc 'invalid 'invalid))))

(define (try-label/ref-pm! ac-list nc pm)
  (and (eq? pm '~label/ref) (handle~label/ref! ac-list nc)))

(define (try-invalid-pm! ac-list nc pm)
  (and (eq? pm 'invalid)
       (cond ((memc nc delim-chars) (try-nc! ac-list nc))
             (else (adorn-char nc 'invalid 'invalid)))))

(define (try-octothorpe-pm! ac-list nc pac pm)
  (and (eq? pm 'octothorpe)
       (cond ((char=? nc #\!) (adorn-char nc 'default '~directive/sharp))
             ((char=? nc #\s) (adorn-char nc 'default '~svector))
             ((char=? nc #\u) (adorn-char nc 'default '~uvector))
             ((char=? nc #\|) (begin-nestc! ac-list nc pac))
             ((char=? nc #\<) (adorn-char nc 'default '~hs-begin))
             ((char=? nc #\\)
              (set-kind! pac 'char)
              (adorn-char nc 'char 'char-1))
             ((char=? nc #\f)
              (set-kind! pac 'false)
              (adorn-char nc 'false '~f/false/fvector))
             ((char=? nc #\t)
              (set-kind! pac 'true)
              (adorn-char nc 'true '~t))
             ((char=? nc #\;)
              (set-kind! pac 'datumc)
              (set-hop! pac 0)
              (set-stack! pac (list ac-list))
              (adorn-char nc 'datumc '~datumc))
             ((char=? nc #\&)
              (set-kind! pac 'box)
              (adorn-char nc 'box 'box))
             ((char=? nc #\()
              (set-kind! pac 'vector)
              (begin-compound! ac-list nc 'vector))
             ((memc nc decimal-chars)
              (adorn-char nc 'default '~label/ref))
             ((char=? nc #\#)
              (cond ((operator-position? (cdr ac-list))
                     (set-mesg! pac '~~rt-syntax)
                     (adorn-char nc 'default '~rt-syntax))
                    (else (set-kind! pac 'repl-ref)
                          (adorn-char nc 'repl-ref '~repl-ref))))
             ((char-ci=? nc #\e)
              (set-kind! pac 'number)
              (adorn-char nc 'number 'exact))
             ((char-ci=? nc #\i)
              (set-kind! pac 'number)
              (adorn-char nc 'number 'inexact))
             ((char-ci=? nc #\b)
              (set-kind! pac 'number)
              (adorn-char nc 'number 'bin))
             ((char-ci=? nc #\o)
              (set-kind! pac 'number)
              (adorn-char nc 'number 'oct))
             ((char-ci=? nc #\d)
              (set-kind! pac 'number)
              (adorn-char nc 'number 'dec))
             ((char-ci=? nc #\x)
              (set-kind! pac 'number)
              (adorn-char nc 'number 'hex))
             ((memc nc delim-chars)
              (set-kind! pac 'repl-ref)
              (try-nc! ac-list nc))
             (else (adorn-char nc 'invalid 'invalid)))))

(define (try-quote-pm! ac-list nc pac pm)
  (cond ((memq pm '(quasiquote quote))
         (or (try-context! ac-list nc pac) (try-nc! ac-list nc)))
        ((eq? pm 'unquote)
         (if (and (char=? nc #\@) (char=? (get-char pac) #\,))
             (adorn-char nc 'abbrev 'unquote)
             (or (try-context! ac-list nc pac) (try-nc! ac-list nc))))
        (else #f)))

(define (try-shebang-pm! ac-list nc pm)
  (and (eq? pm 'shebang)
       (cond ((char=? nc #\newline) (try-nc! ac-list nc))
             (else (adorn-char nc 'shebang 'shebang)))))

(define (try~repl-ref-pm! ac-list nc pm)
  (and (eq? pm '~repl-ref)
       (cond ((char=? nc #\#) (adorn-char nc 'repl-ref '~repl-ref))
             ((memc nc delim-chars) (try-nc! ac-list nc))
             (else (revise-until! ac-list 'default 'octothorpe)
                   (adorn-char nc 'default #f)))))

(define (try-equal-sign-pm! ac-list nc pac pm)
  (and (eq? pm 'equal-sign)
       (cond ((char=? nc #\>)
              (set-kind! pac 'aux-syntax)
              (adorn-char nc 'aux-syntax 'fat-arrow))
             (else (adorn-char nc 'default #f)))))

(define (try-fat-arrow-pm! ac-list nc pm)
  (and (eq? pm 'fat-arrow)
       (cond ((memc nc delim-chars) (try-nc! ac-list nc))
             (else (revise-until! ac-list 'default 2)
                   (adorn-char nc 'default #f)))))
