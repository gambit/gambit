;; Copyright (c) 2024 by Macon Gambill, all rights reserved.

(define (try-pm! ac-list nc pac)
  (let ((pm (get-mesg pac)))
    (and pm (or (try-bind-pm!                ac-list nc pac pm)
                (try-boolean/hvector-pm!     ac-list nc pm)
                (try-box-pm!                 ac-list nc pm)
                (try-char-pm!                ac-list nc pac pm)
                (try-datumc-pm!              ac-list nc pac pm)
                (try-datumc-linec-pm!        ac-list nc pm)
                (try-directive/sharp-pm!     ac-list nc pm)
                (try-equal-sign-pm!          ac-list nc pac pm)
                (try-fat-arrow-pm!           ac-list nc pm)
                (try-hs-pm!                  ac-list nc pm)
                (try-symmetric-pm!           ac-list nc pac pm)
                (try-invalid-pm!             ac-list nc pm)
                (try-label/ref-pm!           ac-list nc pm)
                (try-linec-pm!               ac-list nc pac pm)
                (try-nestc-pm!               ac-list nc pac pm)
                (try-numeric-pm!             ac-list nc pm)
                (try-octothorpe-pm!          ac-list nc pac pm)
                (try-quote-pm!               ac-list nc pac pm)
                (try~repl-ref-pm!            ac-list nc pm)
                (try~rt-syntax-pm!           ac-list nc pac pm)
                (try~~rt-syntax-pm!          ac-list nc pac pm)
                (try-rt-syntax-ident-end-pm! ac-list nc pac pm)
                (try-shebang-pm!             ac-list nc pm)))))

(define try-context!
  (let ((default+no-mesg/rt-syntax?
          (lambda (ac)
            (and (eq? (get-kind ac) 'default)
                 (let ((mesg (get-mesg ac)))
                   (or (not mesg)
                       (memq mesg '(~rt-syntax ~~rt-syntax)))))))
        (valid-keyword?
         (lambda (ac-list nc pc)
           (and (char=? pc #\:) (memc nc delim-chars)
                (let ((rest (cdr ac-list)))
                  (and (not (null? rest))
                       (not (memc (get-char (car rest)) delim-chars)))))))
        (~~rt-syntax?
         (lambda (ac-list nc)
           (and (not (char=? nc #\#))
                (operator-position? ac-list)
                (could-match-one-of? runtime-syntax (list nc))))))
    (lambda (ac-list nc pac)
      (let ((pc (get-char pac)))
        (cond ((not pc) #f)
              ((and (char=? pc #\.) (memc nc whitespace-chars))
               (let ((rest (cdr ac-list)))
                 (unless (null? rest)
                   (when (memq (get-kind (car rest)) atmosphere-kinds)
                     (set-kind! pac 'dot))))
               (try-nc! ac-list nc))
              ((and (char=? nc #\=)
                    (atmosphere? (car ac-list))
                    (not (operator-position? ac-list))
                    (eq? (rt-syntax-mesg (up-list ac-list)) 'rt-aux-active))
               (adorn-char nc 'default 'equal-sign))
              ((valid-keyword? ac-list nc pc)
               (revise-while! ac-list 'keyword default+no-mesg/rt-syntax?)
               (try-nc! ac-list nc))
              ((and (not (char=? nc #\|)) (memc nc delim-chars))
               (try-nc! ac-list nc))
              ((~~rt-syntax? ac-list nc)
               (if (matches-one-of? runtime-syntax (list nc))
                   (adorn-char nc 'rt-syntax '~~rt-syntax)
                   (adorn-char nc 'default '~~rt-syntax)))
              (else #f))))))

(define (^handle:potential-decimal kind ~mesg)
  (lambda (ac-list nc)
    (cond ((null? ac-list) (adorn-char nc kind ~mesg))
          (else (let ((pac (car ac-list)))
                  (if (or (memq (get-kind pac) (cons 'box atmosphere-kinds))
                          (memc (get-char pac) delim-chars))
                      (adorn-char nc kind ~mesg)
                      (adorn-without-context nc)))))))

(define handle:decimal-char (^handle:potential-decimal 'number 'dec.num))

(define handle:dot (^handle:potential-decimal 'default '~dec-num))

(define handle:plus/minus
  (^handle:potential-decimal 'default '~inf/nan/dec.num))

(define (adorn-without-context nc)
  (cond ((char=? nc #\\) (adorn-char nc 'infix #f))
        ((char=? nc #\|) (adorn-char nc 'ident #f))
        ((char=? nc #\") (adorn-char nc 'string #f))        
        ((char=? nc #\') (adorn-char nc 'abbrev 'quote))
        ((char=? nc #\`) (adorn-char nc 'abbrev 'quasiquote))
        ((char=? nc #\,) (adorn-char nc 'abbrev 'unquote))
        ((memc nc whitespace-chars) (adorn-char nc 'whitespace #f))
        (else (adorn-char nc 'default #f))))

(define (handle:octothorpe ac-list nc)
  (cond ((null? ac-list) (adorn-char nc 'default 'octothorpe))
        (else (let ((pac (car ac-list)))
                (if (or (memq (get-kind pac) (cons 'box atmosphere-kinds))
                        (memc (get-char pac) delim-chars))
                    (adorn-char nc 'default 'octothorpe)
                    (adorn-char nc 'default #f))))))

(define (handle:semicolon ac-list nc)
  (let ((ac (adorn-char nc 'linec 'linec 0)))
    (set-stack! ac (list (cons ac ac-list)))
    ac))

(define (try-nc! ac-list nc)
  (cond ((char=? nc #\") (begin-symmetric ac-list nc 'string))
        ((char=? nc #\.) (handle:dot ac-list nc))
        ((char=? nc #\#) (handle:octothorpe ac-list nc))
        ((char=? nc #\;) (handle:semicolon ac-list nc))
        ((char=? nc #\|) (if (operator-position? ac-list)
                             (begin-symmetric ac-list nc '~rt-syntax-ident)
                             (begin-symmetric ac-list nc 'ident)))
        ((memc nc compound-begin-chars) (begin-compound! ac-list nc 'list))
        ((memc nc compound-end-chars) (end-compound! ac-list nc))
        ((memc nc decimal-chars) (handle:decimal-char ac-list nc))
        ((memc nc '(#\- #\+)) (handle:plus/minus ac-list nc))
        (else (adorn-without-context nc))))

(define (adorn-loop! unadorned adorned)
  (if (null? unadorned)
      adorned
      (adorn-loop! (cdr unadorned)
                   (cons (let ((nc (car unadorned)))
                           (cond ((null? adorned) (try-nc! adorned nc))
                                 (else (let ((pac (car adorned)))
                                         (or (try-pm! adorned nc pac)
                                             (try-context! adorned nc pac)
                                             (try-nc! adorned nc))))))
                         adorned))))

(define (maybe-handle:shebang chars adorned)
  (if (and (null? adorned) (not (null? chars)) (not (null? (cdr chars)))
           (char=? (car chars) #\#) (char=? (cadr chars) #\!))
      (let ((trunc (cddr chars)))
        (if (and (not (null? trunc)) (memc (car trunc) '(#\/ #\space #\tab)))
            (let ((first-ac (adorn-char #\# 'shebang 'shebang))
                  (second-ac (adorn-char #\! 'shebang 'shebang)))
              (adorn-loop! trunc (list second-ac first-ac)))
            (adorn-loop! chars adorned)))
      (adorn-loop! chars adorned)))

(define (adorn! chars . so-far)
  (let ((char-list (cond ((string? chars) (string->list chars))
                         ((char? chars) (list chars))
                         (else chars))))
    (maybe-handle:shebang char-list (if (null? so-far) so-far (car so-far)))))

(define reverse+simplify-kinds!
  (let ((def-like-syms '( defun-proc sv-define mv-define mv-define-rest
                          defproc-proc ))
        (let-like-syms '( defun-param named-let sv-let mv-let mv-let-rest
                          lambda-bind lambda-rest case-lambda-bind
                          opt-bind opt-init rest-bind defproc-param
                          defproc-spec rest-spec ))
        (syntax-kinds '(rt-syntax aux-syntax rt-syntax-ident))
        (empty-kinds (map ->empty non-syntax-compounds)))
    (let ((all-compounds (append compound-kinds (map ->empty compound-kinds)))
          (def-like-binds (append def-like-syms (map ->ident def-like-syms)))
          (def-like-escapes (map ->esc (map ->ident def-like-syms)))
          (let-like-binds (append let-like-syms (map ->ident let-like-syms)))
          (let-like-escapes (map ->esc (map ->ident let-like-syms))))
      (lambda (ac-list)
        (let simplify! ((unsimplified ac-list) (simplified '()))
          (if (null? unsimplified)
              simplified
              (let* ((ac (car unsimplified)) (kind (get-kind ac)))
                (cond
                 ((eq? kind 'directive) (set-kind! ac 'atmosphere))
                 ((eq? kind '~rt-syntax-ident) (set-kind! ac 'ident))
                 ((eq? kind '~rt-syntax-ident-esc) (set-kind! ac 'ident-esc))
                 ((eq? kind 'hs-body) (set-kind! ac 'string))                 
                 ((eq? kind 'rt-syntax-ident-esc) (set-kind! ac 'syntax-esc))
                 ((memq kind '(false true)) (set-kind! ac 'boolean))
                 ((memq kind def-like-binds) (set-kind! ac 'def-like-bind))
                 ((memq kind def-like-escapes) (set-kind! ac 'def-like-esc))
                 ((memq kind let-like-binds) (set-kind! ac 'let-like-bind))
                 ((memq kind let-like-escapes) (set-kind! ac 'let-like-esc))
                 ((memq kind comment-kinds) (set-kind! ac 'atmosphere))
                 ((memq kind syntax-kinds) (set-kind! ac 'syntax))
                 ((memq kind empty-kinds) (set-kind! ac 'compound-empty))
                 ((memq kind all-compounds) (set-kind! ac 'compound)))
                (simplify! (cdr unsimplified) (cons ac simplified)))))))))
