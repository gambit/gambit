#!/usr/bin/env gsi-script
;; Copyright (c) 2024 by Macon Gambill, all rights reserved.

(define (main . args)
  (write-string "@comment Generated by write-macros+vars.scm\n\n")
  (for-each write-lisp-syntax-macro lisp-syntax-classes)
  (write-visual-divider)
  (for-each (lambda (args) (apply write-par-macro args))
            '(("pari" "1") ("parii" "2") ("pariii" "3") ("pariv" "4")
              ("parv" "5") ("parvi" "6") ("parvii" "7") ("parviii" "8")
              ("parix" "9")))
  (write-visual-divider)
  (for-each (lambda (args) (apply write-var-macro args))
            '(("vari" "1") ("varii" "2") ("variii" "3") ("variv" "4")
              ("varv" "5") ("varvi" "6") ("varvii" "7") ("varviii" "8")
              ("varix" "9")))
  (write-visual-divider)
  (write-ok-macro)
  (write-exception-macro)
  (write-problem-macro)
  (write-visual-divider)
  (write-opt-macro)
  (write-defdots-macro)
  (write-todo-macro)
  (write-quotedbl-macro)
  (write-visual-divider)
  (write-vars))

(define write-vars
  (let ((write-set
         (lambda (flag/value)
           (write-string
            (string-append "@set "
                           (car flag/value)
                           " "
                           (cadr flag/value)
                           "\n"))))
        (write-rnrs
         (lambda (n)
           (write-string
            (string-append "@set R" n
                           "RS @inlinefmtifelse{info,@acronym{R" n
                           "RS},@inlinefmtifelse{plaintext,@acronym{R" n
                           "RS},@acronym{R@sup{" (string-downcase n)
                           "}RS}}}\n")))))
    (lambda ()
      (for-each write-set
                '(("REVISION" "Revised")
                  ("VERSION" "4.9.5")
                  ("HOMEPAGEURL" "https://gambitscheme.org")
                  ("GITHUBURL" "https://github.com/gambit/gambit")))
      (for-each write-rnrs '("7" "5" "4" "N")))))

(define write-visual-divider 
  (let ((cmnt "@comment "))
    (lambda (#!optional (char #\=) (full-length 79))
      (let loop ((chars '(#\newline)) (i (- full-length (string-length cmnt))))
        (if (positive? i)
            (loop (cons char chars) (- i 1))
            (write-string (string-append cmnt (list->string chars))))))))

(define lisp-syntax-classes
  '(abbrev
    atmosphere
    boolean
    box
    char
    char-body
    compound
    compound-empty
    datum-label
    datum-ref
    def-like-bind
    def-like-esc
    dot
    dsssl
    hs-begin
    hs-key
    ident
    ident-esc
    invalid
    key-bind
    key-init
    keyword
    let-like-bind
    let-like-esc
    number
    repl-ref
    serial-ref
    sharp
    shebang
    string
    string-esc
    syntax
    syntax-esc))

(define kind->macro-name
  (let ((rev-string->list (lambda (str) (reverse (string->list str)))))
    (lambda (kind)
      (let loop ((old (string->list (symbol->string kind))) (new '()))
        (if (null? old)
            (reverse new)
            (let ((next (car old)))
              (cond
               ((char=? next #\-)
                (loop (cdr old) new))
               ((char=? next #\+)
                (loop (cdr old) (append (rev-string->list "PLUS") new)))
               ((char=? next #\/)
                (loop (cdr old) (append (rev-string->list "SLASH") new)))
               ((char=? next #\~)
                (loop (cdr old) (append (rev-string->list "TILDE") new)))
               ((char=? next #\#)
                (loop (cdr old) (append (rev-string->list "OCTOTHORPE") new)))
               ((char=? next #\0)
                (loop (cdr old) (append (rev-string->list "ZERO") new)))
               ((char=? next #\1)
                (loop (cdr old) (append (rev-string->list "I") new)))
               ((char=? next #\2)
                (loop (cdr old) (append (rev-string->list "II") new)))
               ((char=? next #\3)
                (loop (cdr old) (append (rev-string->list "III") new)))
               ((char=? next #\4)
                (loop (cdr old) (append (rev-string->list "IV") new)))
               ((char=? next #\5)
                (loop (cdr old) (append (rev-string->list "V") new)))
               ((char=? next #\6)
                (loop (cdr old) (append (rev-string->list "VI") new)))
               ((char=? next #\7)
                (loop (cdr old) (append (rev-string->list "VII") new)))
               ((char=? next #\8)
                (loop (cdr old) (append (rev-string->list "VIII") new)))
               ((char=? next #\9)
                (loop (cdr old) (append (rev-string->list "IX") new)))
               (else (loop (cdr old) (cons next new))))))))))

(define (write-lisp-syntax-macro kind)
  (write-string
   (string-append "@macro "
                  (list->string (kind->macro-name kind))
                  " {xx}\n"
                  "@inlinefmtifelse{html,@inlineraw{html,<span class=\""
                  (symbol->string kind)
                  "\">\\xx\\</span>},\\xx\\}\n"
                  "@end macro\n")))

(define (write-par-macro macro-name number-string)
  (write-string
   (string-append "@macro "
                  macro-name
                  " {param}\n"
                  "@inlinefmtifelse{info,\\param\\"
                  number-string
                  ",@inlinefmtifelse{plaintext,\\param\\"
                  number-string
                  ",\\param\\@sub{"
                  number-string
                  "}}}\n"
                  "@end macro\n")))

(define (write-var-macro macro-name number-string)
  (write-string
   (string-append "@macro "
                  macro-name
                  " {var}\n"
                  "@inlinefmtifelse{info,@var{\\var\\"
                  number-string
                  "},@inlinefmtifelse{plaintext,@var{\\var\\"
                  number-string
                  "},@var{\\var\\@sub{"
                  number-string
                  "}}}}\n"
                  "@end macro\n")))

(define (write-exception-macro)
  (write-string #<<EOF
@macro exception {kind}
@arrow{} @inlinefmtifelse{html,@inlineraw{html,<span class="exception">\kind\ exception</span>},\kind\ exception}
@end macro

EOF
))

(define (write-ok-macro)
  (write-string #<<EOF
@macro ok {val}
@result{} @inlinefmtifelse{html,@inlineraw{html,<span class="ok">\val\</span>},\val\}
@end macro

EOF
))

(define (write-problem-macro)
  (write-string #<<EOF
@macro problem {p}
@arrow{} @inlinefmtifelse{html,@inlineraw{html,<span class="problem">\p\</span>},\p\}
@end macro

EOF
))

(define (write-defdots-macro)
  (write-string (string-append "@macro defdots {}\n"
                               "@inlinefmtifelse{html,@inlineraw{html,"
                               "<span class=\"def-dots\">&hellip;</span>}"
                               ",@dots{}}\n"
                               "@end macro\n")))

(define (write-opt-macro)
  (write-string #<<EOF
@rmacro opt {arg}
@inlinefmtifelse{html,@inlineraw{html,<span class="def-bracket">[</span>}\arg\@inlineraw{html,<span class="def-bracket">]</span>},[\arg\]}
@end rmacro

EOF
))

(define (write-todo-macro)
  (write-string #<<EOF
@macro todo {t}
@inlinefmtifelse{html,@inlineraw{html,<span class="todo">@sc{TODO}:</span> \t\},@sc{TODO}: \t\}
@end macro

EOF
))

(define (write-quotedbl-macro)
  (write-string #<<EOF
@macro quotedbl {text}
@inlinefmtifelse{tex,``\text\'',@quotedblleft{}\text\@quotedblright{}}
@end macro

EOF
))
